{
  "_comment": null,
  
  "title": "25. 五子棋",
  "createDate": 1745769540000,
  "collections": [],
  "problem": [
    "檢查10*10五子棋，找出所有「只差一顆棋子就能構成五子連線」的位置",
    "連線方向包含水平（→）、垂直（↓）、左斜（↙）、右斜（↘）",
    "棋盤中1表示有放棋子，0表示沒有放棋子",
    "棋子位置表示方法nm為第n列第m行，例如：06表示第0列第6行",
    "",
    "五個棋子連為一線，且不能出現六子或更長的連線情形，例如：",
    "0 0 1 1 1 1 0 1 0 0中，第1個位置放棋子可以構成一條五子連線",
    "若第6個位置放棋子的話則為六子連線，不構成五子連線",
    "",
    "【輸入說明】",
    "輸入10*10由1和0組成的棋盤，每格之間以空格隔開",
    "",
    "範例輸入：",
    "0 0 1 0 0 0 0 0 0 1",
    "0 0 0 1 0 0 0 1 0 0",
    "1 0 0 0 1 0 0 0 0 0",
    "0 1 0 0 1 0 1 1 1 1",
    "0 0 0 0 1 0 1 0 0 0",
    "0 0 0 1 0 0 0 1 0 0",
    "0 0 1 0 0 0 0 1 0 0",
    "0 1 0 0 0 0 0 1 0 0",
    "0 0 0 0 0 0 0 1 0 0",
    "0 1 1 0 0 1 1 0 1 1",
    "",
    "【輸出說明】",
    "輸出可以構成五子連線的棋子位置及可以構成的五子連線數量，中間以空格隔開",
    "且須依照棋子可以構成的五子連線數量由多到少排序，若數量相同，則依照位置數字由小到大輸出",
    "",
    "範例輸出：",
    "97 2（在第9列第7行放棋子，可以構成2條五子連線）",
    "35 1（在第3列第5行放棋子，可以構成1條五子連線）",
    "80 1（在第8列第0行放棋子，可以構成1條五子連線）"
  ],
  "testcase": {
    "codeType": 1,
    "cases": [
      {
        "input": [
          "0 1 1 1 1 0 0 0 0 1",
          "0 0 0 0 0 0 0 0 0 0",
          "0 0 0 0 0 0 0 0 1 0",
          "0 1 1 0 0 0 0 1 0 0",
          "0 0 0 0 0 0 0 0 0 0",
          "1 0 0 0 0 1 0 0 0 1",
          "0 1 0 0 1 0 0 0 0 0",
          "0 0 1 0 0 0 0 0 0 1",
          "0 0 0 0 0 0 0 1 0 1",
          "1 1 0 0 1 0 0 0 0 1"
        ],
        "output": [
          "00 1",
          "05 1",
          "46 1",
          "69 1",
          "83 1"
        ]
      },
      {
        "input": [
          "0 1 0 0 0 0 1 0 0 0",
          "0 0 0 0 0 1 0 0 0 0",
          "1 0 0 0 0 0 0 0 0 0",
          "0 0 0 1 0 0 0 1 1 1",
          "0 0 1 0 0 0 0 0 0 0",
          "0 1 0 0 1 0 0 0 1 0",
          "0 0 0 0 0 0 0 0 0 0",
          "0 0 0 0 1 0 0 0 0 1",
          "1 1 0 0 1 0 0 0 0 0",
          "0 0 0 0 1 0 1 1 1 1"
        ],
        "output": [
          "64 1"
        ]
      },
      {
        "input": [
          "0 0 1 0 0 0 0 0 1 0",
          "0 1 0 0 0 0 0 0 1 0",
          "0 0 0 0 1 0 0 0 0 0",
          "0 0 0 1 1 0 0 0 1 0",
          "0 1 1 1 0 1 0 0 1 0",
          "1 0 0 0 1 1 0 0 0 0",
          "0 1 0 0 1 0 1 0 0 1",
          "0 0 1 0 0 0 0 1 0 0",
          "0 0 0 1 0 0 0 0 0 0",
          "0 1 1 1 0 1 0 1 1 0"
        ],
        "output": [
          "44 3",
          "94 2",
          "28 1"
        ]
      },
      {
        "input": [
          "0 0 1 0 0 0 0 0 0 1",
          "0 0 0 1 0 0 0 1 0 0",
          "1 0 0 0 1 0 0 0 0 0",
          "0 1 0 0 1 0 1 1 1 1",
          "0 0 0 0 1 0 1 0 0 0",
          "0 0 0 1 0 0 0 1 0 0",
          "0 0 1 0 0 0 0 1 0 0",
          "0 1 0 0 0 0 0 1 0 0",
          "0 0 0 0 0 0 0 1 0 0",
          "0 1 1 0 0 1 1 0 1 1"
        ],
        "output": [
          "97 2",
          "35 1",
          "80 1"
        ]
      }
    ]
  },
  "sampleCode": [
    "#include <stdio.h>",
    "#include <stdlib.h>",
    "",
    "int calcVerrtical(int x, int y, int arr[10][10]) {",
    "  int vertical = 1;",
    "",
    "  for (int i=x-1; i>=0; i--) {",
    "    if (arr[i][y] == 0) break;",
    "    vertical++;",
    "  }",
    "",
    "  for (int i=x+1; i<10; i++) {",
    "    if (arr[i][y] == 0) break;",
    "    vertical++;",
    "  }",
    "",
    "  return vertical;",
    "}",
    "",
    "int calcHorizontial(int x, int y, int arr[10][10]) {",
    "  int horizontial = 1;",
    "  ",
    "  for (int i=y-1; i>=0; i--) {",
    "    if (arr[x][i] == 0) break;",
    "    horizontial++;",
    "  }",
    "",
    "  for (int i=y+1; i<10; i++) {",
    "    if (arr[x][i] == 0) break;",
    "    horizontial++;",
    "  }",
    "",
    "  return horizontial;",
    "}",
    "",
    "int calcRTtoLB(int x, int y, int arr[10][10]) {",
    "  int dots = 1;",
    "",
    "  for (int i=x+1, j=y-1; i<10 && j>=0; i++, j--) {",
    "    if (arr[i][j] == 0) break;",
    "    dots++;",
    "  }",
    "",
    "  for (int i=x-1, j=y+1; i>=0 && j<10; i--, j++) {",
    "    if (arr[i][j] == 0) break;",
    "    dots++;",
    "  }",
    "",
    "  return dots;",
    "}",
    "",
    "int calcRBtoLT(int x, int y, int arr[10][10]) {",
    "  int dots = 1;",
    "",
    "  for (int i=x+1, j=y+1; i<10 && j<10; i++, j++) {",
    "    if (arr[i][j] == 0) break;",
    "    dots++;",
    "  }",
    "",
    "  for (int i=x-1, j=y-1; i>=0 && j>=0; i--, j--) {",
    "    if (arr[i][j] == 0) break;",
    "    dots++;",
    "  }",
    "",
    "  return dots;",
    "}",
    "",
    "int calcLine(int x, int y, int arr[10][10]) {",
    "  return ",
    "    ( calcHorizontial(x, y, arr) == 5 ? 1 : 0 ) +",
    "    ( calcVerrtical(x, y, arr) == 5 ? 1 : 0 ) +",
    "    ( calcRBtoLT(x, y, arr) == 5 ? 1 : 0 ) +",
    "    ( calcRTtoLB(x, y, arr) == 5 ? 1 : 0 );",
    "}",
    "",
    "int cmp(const void *a, const void *b) {",
    "  int *h = (int *) a;",
    "  int *k = (int *) b;",
    "",
    "  if (*h / 1000 != *k / 1000) ",
    "    return (*k / 1000) - (*h / 1000);",
    "",
    "  // return *k-*h;",
    "  return (*h % 1000) - (*k % 1000);",
    "}",
    "",
    "int main() {",
    "  int arr[10][10];",
    "",
    "  int result[100];",
    "",
    "  for (int i=0; i<100; i++) {",
    "    scanf(\"%d\", &(arr[i/10][i%10]));",
    "  }",
    "",
    "  getchar();",
    "",
    "  int count = 0;",
    "",
    "  for (int i=0; i<100; i++) {",
    "",
    "    if (arr[i/10][i%10] == 1) continue;",
    "",
    "    int res = calcLine(i/10, i%10, arr);",
    "",
    "    if (res != 0) {",
    "      result[count++] = res*1000 + i;",
    "    }",
    "  }",
    "",
    "  qsort(result, count, sizeof(int), cmp);",
    "",
    "  for (int i=0; i<count; i++) {",
    "    int cnt = result[i] / 1000;",
    "    int x = (result[i] % 1000) / 10;",
    "    int y = (result[i] % 1000) % 10;",
    "",
    "    printf(\"%d%d %d\\n\", x, y, cnt);",
    "  }",
    "",
    "  return 0;",
    "}"
  ]
}