{
  "uuid": "ffb8fd68-11ef-41a6-ae77-f0d1394d08ec",
  "title": "26. 騎車",
  "createDate": 1747151940000,
  "collections": [
    "eb097620-6eca-4b6b-9bc3-f7adb2b5e94d"
  ],
  "problem": [
    "小明騎腳踏車挑戰一日N塔，N<10。每一個高塔在編號 1, 2,3, ...,N 城市中。兩兩個城市都有一段距離的公路相連。小明從第 1 個城市出發，規劃出最短路徑後，依規劃順序騎過每一個城市。但當騎到第X城市時，獲得消息發現某兩個城市的交通中斷。因此小明需要從第X城市開始，重新規劃未走完的城市之最短距離。請計算完成一日N塔所需距離。",
    "",
    "城市之間的路徑",
    "0 2 1 -1",
    "2 0 5 2",
    "1 5 0 1",
    "-1 2 1 0",
    "以第一行為範例。例如",
    "0 代表城市 1 與城市 1無距離,",
    "2 代表城市 1 和城市 2 的距離是 2,",
    "1 代表城市 1 和城市 3 的距離是 1,",
    "-1 代表城市 1 無法抵達城市 4",
    "",
    "<img src='https://imgur.com/EO4GGig.png'>",
    "",
    "<img src='https://imgur.com/J2wnqRp.png'>",
    "",
    "【輸入說明】",
    "第一行輸入一個整數N代表有幾座塔(N <= 10)",
    "其後N行代表城市N與其他城市所相鄰的距離",
    "下一行輸入一個整數C代表在原先計算的最短路徑中騎到第幾個城市時發生某段路無法通行",
    "再下一行輸入兩個整數u, v 代表哪一段路無法通行",
    "",
    "範例輸入說明:",
    "4\t\t\t(代表有4座城市)",
    "0 2 1 -1\t\t(第一座城市與其他座城市的距離)",
    "2 0 5 2\t\t(第二座城市與其他座城市的距離)",
    "1 5 0 1\t\t(第三座城市與其他座城市的距離)",
    "-1 2 1 0\t\t(第四座城市與其他座城市的距離)",
    "2\t\t\t(代表走到第幾個城市發生道路無法通行)",
    "3 4\t\t\t(代表3, 4城市之間的路無法通行)",
    "",
    "【輸出說明】",
    "第一行輸出小明完成一日N塔的路徑",
    "第二行輸出完成路徑所花的距離",
    "",
    "(原本計算的最短路徑為1 3 4 2,因走到第2個城市發現3 4路徑無法通行,所以保留走過的1 3路徑往後找沒有3 4路徑的又可以走完所有城市的路徑)",
    "",
    "範例輸出說明:",
    "1 3 2 4\t\t(最終完成一日N塔的路徑)",
    "8\t\t\t(花費的距離 : 1+5+2 = 8)"
  ],
  "testcase": {
    "codeType": 1,
    "cases": [
      {
        "input": [
          "5",
          "0 3 1 4 2",
          "3 0 6 10 -1",
          "1 6 0 6 10",
          "4 10 6 0 4",
          "2 -1 10 4 0",
          "3",
          "4 3"
        ],
        "output": [
          "1 5 4 2 3",
          "22"
        ]
      },
      {
        "input": [
          "6",
          "0 1 5 1 9 -1",
          "1 0 4 7 -1 3",
          "5 4 0 9 4 8",
          "1 7 9 0 -1 9",
          "9 -1 4 -1 0 10",
          "-1 3 8 9 10 0",
          "3",
          "6 2"
        ],
        "output": [
          "1 4 6 5 3 2",
          "28"
        ]
      },
      {
        "input": [
          "8",
          "0 3 -1 6 -1 -1 2 -1",
          "3 0 1 -1 3 4 -1 -1",
          "-1 1 0 5 -1 -1 3 8",
          "6 -1 5 0 2 -1 -1 4",
          "-1 3 -1 2 0 6 -1 1",
          "-1 4 -1 -1 6 0 2 -1",
          "2 -1 3 -1 -1 2 0 5",
          "-1 -1 8 4 1 -1 5 0",
          "4",
          "2 3"
        ],
        "output": [
          "1 7 6 2 5 8 4 3",
          "21"
        ]
      }
    ]
  },
  "sampleCode": [
    "#include <stdio.h>",
    "",
    "#define INFINITY 228922",
    "",
    "int findMinIndex(int arr[], int count) {",
    "  int current = 0;",
    "",
    "  for (int i=1; i<count; i++)",
    "    if (arr[i] < arr[current]) ",
    "      current = i;",
    "",
    "  return current;",
    "}",
    "",
    "int isIn(int arr[], int target, int count) {",
    "  for (int i=0; i<count; i++)",
    "    if (target == arr[i]) return 1;",
    "",
    "  return 0;",
    "}",
    "",
    "int calculateDistance(int route[100][100], int *seen, int count) {",
    "  int distance = 0;",
    "",
    "  int now, next;",
    "  for (int i=0; i<count-1; i++) {",
    "    now = seen[i];",
    "    next = seen[i+1];",
    "    distance += route[now][next];",
    "  }",
    "",
    "  return distance;",
    "}",
    "",
    "int *bfs(int route[100][100], int *seen, int count, int index) {",
    "  static int buf[10];",
    "  static int min = INFINITY;",
    "",
    "  int current = seen[index];",
    "",
    "  // We walk through all path",
    "  if (count == index+1) {",
    "    int result = calculateDistance(route, seen, count);",
    "    if (result < min) {",
    "      min = result;",
    "      for (int i=0; i<count; i++) buf[i] = seen[i];",
    "    }",
    "    return NULL;",
    "  }",
    "",
    "  for (int next=0; next<count; next++) {",
    "    int dist = route[current][next];",
    "    ",
    "    // Skip if route is not available or is itslef",
    "    if (dist <= 0)",
    "      continue;",
    "    ",
    "    // Skip if the route is already seen",
    "    if (isIn(seen, next, index+1))",
    "      continue;",
    "",
    "    seen[index + 1] = next;",
    "    bfs(route, seen, count, index+1);",
    "  }",
    "",
    "  // If this happened, means that this route is not possible",
    "  return buf;",
    "}",
    "",
    "int *bfsWithFilter(int route[100][100], int *seen, int count, int index, int *breakCity) {",
    "  static int buf[10];",
    "  static int min = INFINITY;",
    "",
    "  int current = seen[index];",
    "",
    "  // We walk through all path",
    "  if (count == index+1) {",
    "    int result = calculateDistance(route, seen, count);",
    "    if (result < min) {",
    "      min = result;",
    "      for (int i=0; i<count; i++) buf[i] = seen[i];",
    "    }",
    "    return NULL;",
    "  }",
    "",
    "  int tmp, minValue = INFINITY;",
    "",
    "  for (int next=0; next<count; next++) {",
    "    int dist = route[current][next];",
    "    ",
    "    // Skip if route is not available or is itslef",
    "    if (dist <= 0)",
    "      continue;",
    "    ",
    "    // // Skip if the route is forbidden",
    "    if (",
    "      isIn(breakCity, current, 2) &&",
    "      isIn(breakCity, next, 2)",
    "    ) continue;",
    "    ",
    "    // Skip if the route is already seen",
    "    if (isIn(seen, next, index+1))",
    "      continue;",
    "",
    "    tmp = seen[index + 1];",
    "    ",
    "    seen[index + 1] = next;",
    "    bfsWithFilter(route, seen, count, index+1, breakCity);",
    "  }",
    "",
    "  // If this happened, means that this route is not possible",
    "  return buf;",
    "}",
    "",
    "int main() {",
    "  int count;",
    "",
    "  scanf(\"%d\", &count);",
    "  getchar();",
    "",
    "  int route[100][100];",
    "",
    "  for (int i=0; i<count; i++) {",
    "    for (int j=0; j<count; j++) ",
    "      scanf(\"%d\", &route[i][j]);",
    "    getchar();",
    "  }",
    "",
    "  int seen[10] = {0};",
    "",
    "  int breakPoints[2], breakNum;",
    "  ",
    "  scanf(\"%d\", &breakNum);",
    "  getchar();",
    "",
    "  scanf(\"%d %d\", &breakPoints[0], &breakPoints[1]);",
    "  getchar();",
    "",
    "  breakPoints[0]--;",
    "  breakPoints[1]--;",
    "",
    "  int *res = bfs(route, seen, count, 0);",
    "",
    "  int *res2 = bfsWithFilter(route, res, count, breakNum-1, breakPoints);",
    "",
    "",
    "  for (int i=0; i<count; i++)",
    "    printf(\"%d \", res2[i]+1);",
    "  printf(\"\\n\");",
    "",
    "  printf(\"%d\\n\", calculateDistance(route, res2, count));",
    "",
    "  return 0;",
    "}",
    "",
    "/*",
    "4",
    "0 2 1 -1",
    "2 0 5 2",
    "1 5 0 1",
    "-1 2 1 0",
    "2",
    "3 4",
    "*/"
  ]
}