{
  "uuid": "0e526b75-a149-4073-a8c5-075c68499cf2",
  "title": "19. 大數除法",
  "createDate": 1744027200000,
  "collections": [
    "df834ace-8de1-4f4e-bdcf-8c6b348a2109"
  ],
  "problem": [
    "題目會給予兩個20~40位數(包含上下限)的長正整數做運算，",
    "請根據大數除法計算並輸出商數與餘數。",
    "",
    "兩數相除滿足此等式: a = kq + r，",
    "a代表被除數，k代表非零除數，",
    "其中q為商數且必為整數，而r為餘數，且必為自然數，滿足 0 <= r < |k|",
    "",
    "【輸入說明】",
    "第一行輸入第一個長正整數 a (20 <= strlen(a) <= 40)，代表被除數",
    "第二行輸入第二個長正整數 k (20 <= strlen(k) <= 40)，代表非零除數",
    "",
    "範例輸入：",
    "141978786712730593351144765151826 (被除數)",
    "190277493795263785923452478 (除數)",
    "",
    "【輸出說明】",
    "輸出兩行整數除法運算後的結果,",
    "第一行為商數",
    "第二行為餘數",
    "",
    "範例輸出：",
    "746167 (商數)",
    "0 (餘數)"
  ],
  "testcase": {
    "codeType": 1,
    "cases": [
      {
        "input": [
          "9999999999999999999999999999999999999999",
          "3333333333333333333333333333333333333333"
        ],
        "output": [
          "3",
          "0"
        ]
      },
      {
        "input": [
          "6322083025804530270923509282757380346975",
          "1264416605160906054184701856551476069395"
        ],
        "output": [
          "5",
          "0"
        ]
      },
      {
        "input": [
          "8487528979174018417498589236759279346745",
          "1912490723489072389729385792835792371975"
        ],
        "output": [
          "4",
          "837566085217728858581046065416109858845"
        ]
      },
      {
        "input": [
          "33812904847198749749167264659729735712",
          "2989890771728947948719728947461452"
        ],
        "output": [
          "11309",
          "230109716077397095849992888175044"
        ]
      },
      {
        "input": [
          "1543031303431638460345211301334064",
          "1543031303431638460345211301334069"
        ],
        "output": [
          "0",
          "1543031303431638460345211301334064"
        ]
      }
    ]
  },
  "sampleCode": [
    "#include <stdio.h>",
    "#include <string.h>",
    "",
    "char num1[101], num2[101];",
    "char remainder[202], quotient[202];",
    "",
    "int length(char *string);",
    "void stringReverse(char *string);",
    "void add(char *num1, char *num2, char *result);",
    "void substract(char *num1, char *num2, char *result);",
    "void division(char *num1, char *num2, char *quotient, char *ans);",
    "char compare(char *num1, char *num2);",
    "void convertToChar(char *arr, int length);",
    "void convertToNum(char *arr);",
    "void mutiply(char *num1, char *num2, char *result);",
    "int trim(char *result, int start);",
    "void rationalize(char *buf, int length);",
    "",
    "int main() {",
    "  scanf(\"%s\", num1);",
    "  getchar();",
    "  ",
    "  scanf(\"%s\", num2);",
    "  getchar();",
    "  ",
    "  division(num1, num2, remainder, quotient);",
    "",
    "  printf(\"%s\\n\", remainder);",
    "  printf(\"%s\\n\", quotient);",
    "}",
    "",
    "int length(char *string) {",
    "  int sum = 0;",
    "  while (string[sum] != '\\0') {",
    "    sum ++;",
    "  }",
    "",
    "  return sum;",
    "}",
    "",
    "void add(char *num1, char *num2, char *result) {",
    "  int num1Len = length(num1);",
    "  int num2Len = length(num2);",
    "",
    "  int num1Index = num1Len - 1;",
    "  int num2Index = num2Len - 1;",
    "",
    "  char isNum1Neg = num1[0] == '-';",
    "  char isNum2Neg = num2[0] == '-';",
    "",
    "  if (isNum1Neg && !isNum2Neg) {",
    "    substract(num2, (num1+1), result);",
    "    return;",
    "  }",
    "",
    "  if (!isNum1Neg && isNum2Neg) {",
    "    substract(num1, num2+1, result);",
    "    return;",
    "  }",
    "",
    "  if (isNum1Neg && isNum2Neg) {",
    "    add(num1+1, num2+1, result+1);",
    "    result[0] = '-';",
    "    return;",
    "  }",
    "",
    "  int num1StopRange = isNum1Neg ? 1 : 0;",
    "  int num2StopRange = isNum2Neg ? 1 : 0;",
    "",
    "  convertToNum(num1);",
    "  convertToNum(num2);",
    "",
    "  int index = 0;",
    "",
    "  while (num1Index >= num1StopRange && num2Index >= num2StopRange) {",
    "    result[index] = num1[num1Index] + num2[num2Index];",
    "",
    "    num1Index--;",
    "    num2Index--;",
    "    index++;",
    "  }",
    "",
    "  // Fill up leftover number",
    "  while (num1Index >= num1StopRange || num2Index >= num2StopRange) {",
    "    char n1 = (num1Index >= num1StopRange) ? num1[num1Index] : 0;",
    "    char n2 = (num2Index >= num2StopRange) ? num2[num2Index] : 0;",
    "    ",
    "    result[index] = n1 + n2;",
    "",
    "    num1Index--;",
    "    num2Index--;",
    "    index++;",
    "  }",
    "",
    "  convertToChar(num1, num1Len);",
    "  convertToChar(num2, num2Len);",
    "",
    "  rationalize(result, index);",
    "  ",
    "  index = trim(result, index);",
    "",
    "  convertToChar(result, index+1);",
    "",
    "  stringReverse(result);",
    "}",
    "",
    "void substract(char *num1, char *num2, char *result) {",
    "  char isNum1Neg = num1[0] == '-';",
    "  char isNum2Neg = num2[0] == '-';",
    "",
    "  if (compare(num1, num2) == 0) {",
    "    result[0] = '0';",
    "    result[1] = '\\0';",
    "    return;",
    "  }",
    "",
    "  int num1Len = length(num1);",
    "  int num2Len = length(num2);",
    "",
    "  int num1Index = num1Len - 1;",
    "  int num2Index = num2Len - 1;",
    "",
    "  if (isNum1Neg && !isNum2Neg) {",
    "    add(num1+1, num2, result+1);",
    "",
    "    result[0] = '-';",
    "    return;    ",
    "  }",
    "",
    "  if (!isNum1Neg && isNum2Neg) {",
    "    add(num1, num2+1, result);",
    "",
    "    return;    ",
    "  }",
    "",
    "  if (isNum1Neg && isNum2Neg) {",
    "    substract(num2+1, num1+1, result);",
    "    return;",
    "  }",
    "",
    "  int num1StopRange = isNum1Neg ? 1 : 0;",
    "  int num2StopRange = isNum2Neg ? 1 : 0;",
    "",
    "  if (compare(num1, num2) < 0) {",
    "    substract(num2, num1, result+1);",
    "",
    "    result[0] = '-';",
    "",
    "    return;",
    "  }",
    "",
    "  // Convert all ascii code char to the offset with '0'",
    "  convertToNum(num1);",
    "  convertToNum(num2);",
    "",
    "  int index = 0;",
    "",
    "  while (num1Index >= num1StopRange && num2Index >= num2StopRange) {",
    "    result[index] = num1[num1Index] - num2[num2Index];",
    "",
    "    num1Index--;",
    "    num2Index--;",
    "    index++;",
    "  }",
    "",
    "  // Fill up leftover number",
    "  while (num1Index >= num1StopRange || num2Index >= num2StopRange) {",
    "    char n1 = (num1Index >= num1StopRange) ? num1[num1Index] : 0;",
    "    char n2 = (num2Index >= num2StopRange) ? num2[num2Index] : 0;",
    "    ",
    "    result[index] = n1 - n2;",
    "",
    "    num1Index--;",
    "    num2Index--;",
    "    index++;",
    "  }",
    "",
    "  convertToChar(num1, num1Len);",
    "  convertToChar(num2, num2Len);",
    "",
    "  rationalize(result, index);",
    "  ",
    "  // Find the last index without zero",
    "  index = trim(result, index);",
    "  ",
    "  convertToChar(result, index+1);",
    "",
    "  stringReverse(result);",
    "",
    "  return;",
    "}",
    "",
    "void mutiply(char *num1, char *num2, char *result) {",
    "  char isNum1Neg = num1[0] == '-';",
    "  char isNum2Neg = num2[0] == '-';",
    "",
    "  if (isNum1Neg || isNum2Neg) {",
    "    short isResultNeg = isNum1Neg ^ isNum2Neg;",
    "    ",
    "    if (isNum1Neg) {",
    "      num1 ++;",
    "    }",
    "",
    "    if (isNum2Neg) {",
    "      num2 ++;",
    "    }",
    "    if (isResultNeg) {",
    "      mutiply(num1, num2, result+1);",
    "      result[0] = '-';",
    "    } else {",
    "      mutiply(num1, num2, result);",
    "    }",
    "    return;",
    "  }",
    "  ",
    "  int num1Len = length(num1);",
    "  int num2Len = length(num2);",
    "",
    "  convertToNum(num1);",
    "  convertToNum(num2);",
    "",
    "  for (int index2=0; index2<num2Len ; index2++) {",
    "    for (int index1=0; index1<num1Len ; index1++) {",
    "      result[index1+index2] += num2[num2Len-index2-1] * num1[num1Len-index1-1];",
    "    }",
    "    rationalize(result, num1Len+num2Len);",
    "  }",
    "",
    "  int index = trim(result, num1Len+num2Len);",
    "  convertToChar(result, index+1);",
    "",
    "  stringReverse(result);",
    "}",
    "",
    "void division(char *num1, char *num2, char *quotient, char *remainder) {",
    "  char one[] = \"1\";",
    "",
    "  quotient[0] = '0';",
    "  quotient[1] = '\\0';",
    "",
    "  strcpy(remainder, num1);",
    "",
    "  while (compare(remainder, num2) >= 0) {",
    "    char quotientBuf[200] = {0}, remainderBuf[200] = {0};",
    "",
    "    substract(remainder, num2, remainderBuf);",
    "    add(one, quotient, quotientBuf);",
    "",
    "    strcpy(quotient, quotientBuf);",
    "    strcpy(remainder, remainderBuf);",
    "  }",
    "}",
    "",
    "void stringReverse(char *string) {",
    "  int len = length(string);",
    "  for (int i=0; i < len/ 2 ; i++) {",
    "    char tmp = string[i];",
    "",
    "    string[i] = string[len-i-1];",
    "    string[len-i-1] = tmp;",
    "  }",
    "}",
    "",
    "// Return if num1 is larger than num2",
    "char compare(char *num1, char *num2) {",
    "  char isNum1Neg = num1[0] == '-';",
    "  char isNum2Neg = num2[0] == '-';",
    "",
    "  if (isNum1Neg ^ isNum2Neg) {",
    "    // If num2 is a negative number, then num1 is greater without doubt",
    "    return isNum2Neg ? 1 : -1;",
    "  }",
    "",
    "  int num1Index = length(num1);",
    "  int num2Index = length(num2);",
    "",
    "  if (num1Index != num2Index) {",
    "    return ((num1Index > num2Index) ^ isNum1Neg) ? 1 : -1;",
    "  }",
    "  ",
    "  int index = 0;",
    "  while (index < num1Index) {",
    "    if (num1[index] == num2[index]) {",
    "      index++;",
    "      continue;",
    "    }",
    "    return ((num1[index] > num2[index]) ^ isNum1Neg) ? 1 : -1;   ",
    "  }",
    "",
    "  return 0;",
    "}",
    "",
    "void convertToChar(char *arr, int length) {",
    "  arr[length] = '\\0';",
    "  while (--length >= 0) {",
    "    arr[length] += '0';",
    "  }",
    "}",
    "",
    "void convertToNum(char *arr) {",
    "  int len = length(arr);",
    "  while (--len >= 0) {",
    "    arr[len] -= '0';",
    "  }",
    "}",
    "",
    "int trim(char *result, int start) {",
    "  while (result[start] == 0) {",
    "    start--;",
    "",
    "    if (start < 0) {",
    "      return 0;",
    "    }",
    "  }",
    "",
    "  return start;",
    "}",
    "",
    "void rationalize(char *buf, int length) {",
    "  int index = 0;",
    "  while (index < length) {",
    "    if (buf[index] >= 10) {",
    "      buf[index+1] += buf[index] / 10;",
    "      buf[index] %= 10;",
    "    } else if (buf[index] < 0) {",
    "      buf[index] += 10;",
    "      buf[index+1] -= 1;",
    "    }",
    "    index ++;",
    "  }",
    "}"
  ]
}