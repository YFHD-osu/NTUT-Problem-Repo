{
  "uuid": "298b9dc1-cb02-48e2-8abb-d779b4ab1138",
  "title": "41. 課程教室排程",
  "createDate": 1750175940000,
  "collections": [
    "eb097620-6eca-4b6b-9bc3-f7adb2b5e94d"
  ],
  "problem": [
    "某大學有許多課程須要分配不同教室上課，教室 24 小時開放，每一個課程有不同的使用時間。由於課程眾多，可能發生時間衝突，教務處安排這些課程，優先選取時間上不衝突的課程安排教室。學校希望所有教室能做最有效的利用。教室有容納人數上限，課程有修課人數。每堂課程須全程在某間教室上完，中途不得更改教室。",
    "",
    "【輸入說明】",
    "1. 第一行輸入兩個整數 M,N，M 是教室數量，N 是課程數。",
    "2. 其後 M 行，每一行有 2 個正整數以空白隔開，代表教室編號與容量。",
    "3. 其後 N行，每一行有 4個正整數以空白隔開，代表每一個課程的編號、人數、開始時間、結束時間。時間以 0 代表凌晨 12 點，18 代表下午六點。例如:",
    "1102 50 1 4 #課程 1102 有 50 人用 1 點-4 點共 3 小時。",
    "2103 30 3 15 #課程 2103 有 50 人 用 3點-15 點共 12小時。",
    "4. 最後一行，正整數 b，b=0表示不考慮人數限制，b=1，表示要考慮人數限制。b=2，表示要考慮人數限制，且要輸出課程編號與教室編號。",
    "",
    "輸出說明",
    "1.計算安排到的所有課程，輸出能使用最高總時數。",
    "2.計算安排到的所有課程，輸出能使用的最多課程數。若b=2，輸出課程編號與教室。",
    "3.若一個教室有多個課程，課程取編號數小的優先輸出。",
    "4.若有課程的時長一樣，優先考慮課程編號較大的課程。",
    "",
    "範例輸入說明:",
    "1 3\t\t\t\t(M=1 代表有1間教室，N=3 代表有3堂課程)",
    "1 100\t\t\t(第一間教室，教室編號1，人數上限為100)",
    "101 10 9 11\t\t(第一堂課程，課程的編號=101，人數為10人，時段9~10)",
    "102 20 10 13\t\t(第二堂課程，課程的編號=102，人數為20人，時段10~12)",
    "103 200 9 15\t\t(第三堂課程，課程的編號=103，人數為200人，時段9~15)",
    "2\t\t\t\t(b=2，要考慮人數限制，且要輸出課程編號與教室編號。)",
    "",
    "範例輸出說明:",
    "max hours 3\t\t(三堂課程時間有衝突，且考慮人數限制，選編號102課程)",
    "max courses 1\t\t(這三堂課程只能排一堂課程，所以為1)",
    "102 1\t\t\t(輸出所排入的課程編號與教室編號)"
  ],
  "testcase": {
    "codeType": 1,
    "cases": [
      {
        "input": [
          "2 4",
          "2103 90",
          "1102 80",
          "101 70 4 6",
          "102 80 1 6",
          "103 50 1 3",
          "104 60 1 2",
          "0"
        ],
        "output": [
          "max hours 9",
          "max courses 3"
        ]
      },
      {
        "input": [
          "2 5",
          "2103 90",
          "1102 80",
          "1 60 8 15",
          "2 100 6 17",
          "3 90 10 14",
          "4 50 10 16",
          "5 70 9 14",
          "1"
        ],
        "output": [
          "max hours 13",
          "max courses 2"
        ]
      },
      {
        "input": [
          "3 10",
          "1 100",
          "2 50",
          "3 20",
          "401 110 0 2",
          "402 60 2 7",
          "403 40 4 10",
          "404 20 6 9",
          "405 10 8 10",
          "406 110 10 12",
          "407 60 12 17",
          "408 40 14 19",
          "409 20 16 19",
          "410 10 18 20",
          "2"
        ],
        "output": [
          "max hours 31",
          "max courses 8",
          "402 1",
          "403 2",
          "404 3",
          "405 1",
          "407 1",
          "408 2",
          "409 3",
          "410 1"
        ]
      }
    ]
  },
  "sampleCode": [
    "#include <stdio.h>",
    "#include <stdint.h>",
    "",
    "#define MAXM 10",
    "#define MAXN 32",
    "",
    "typedef struct { int id, cap; } Room;",
    "typedef struct { int id, stu, s, e, dur; } Course;",
    "",
    "/*---------------- 全域資料 ----------------*/",
    "int M, N, bFlag;",
    "Room    R[MAXM];",
    "Course  C[MAXN];",
    "uint64_t conflicts[MAXN];           /* bit j=1 表示 i 與 j 時段衝突 */",
    "",
    "int     bestH, bestC;",
    "uint64_t bestAssign[MAXM];          /* b==2 時記錄 (room→課程集合) */",
    "",
    "/*--------------- 上界：很鬆但夠剪枝 ----------------*/",
    "int remainHours(uint64_t mask){",
    "    int h=0; ",
    "    for(int i=0;i<N;++i) {",
    "        if(! (mask & (1<<i))) continue; ",
    "        ",
    "        return h+=C[i].dur;",
    "    }",
    "}",
    "int remainCnt(uint64_t mask){",
    "    int c=0; for(int i=0;i<N;++i) if(mask&(1<<i)) ++c; return c;",
    "}",
    "",
    "/*--------------- DFS ----------------*/",
    "void dfs(int r, uint64_t mask,",
    "         int curH, int curC,",
    "         uint64_t assign[]",
    "        )",
    "{",
    "    if(r==M || !mask){                     /* 所有教室都處理完 */",
    "        if(curH>bestH || (curH==bestH && curC>bestC)){",
    "            bestH=curH; bestC=curC;",
    "            for(int k=0;k<M;++k) bestAssign[k]=assign[k];",
    "        }",
    "        return;",
    "    }",
    "",
    "    /* 剪枝：粗略上界 */",
    "    int ubH = curH + remainHours(mask);",
    "    int ubC = curC + remainCnt(mask);",
    "    if(ubH < bestH || (ubH==bestH && ubC<=bestC)) return;",
    "",
    "    /* 列舉 mask 的所有子集合 sub */",
    "    for(uint64_t sub=mask; sub; sub=(sub-1)&mask){",
    "        /* 檢查 sub 是否能塞進 R[r] */",
    "        int ok=1, addH=0, addC=0;",
    "        for(int i=0;i<N && ok;++i) if(sub&(1u<<i)){",
    "            if(bFlag && C[i].stu > R[r].cap){ ok=0; break; }",
    "            if(conflicts[i] & (sub^(1u<<i))){ ok=0; break; }",
    "            addH += C[i].dur;  ++addC;",
    "        }",
    "        if(!ok) continue;",
    "",
    "        assign[r]=sub;",
    "        dfs(r+1, mask^sub, curH+addH, curC+addC, assign);",
    "    }",
    "",
    "    /* 也允許這間教室留空 */",
    "    assign[r]=0;",
    "    dfs(r+1, mask, curH, curC, assign);",
    "}",
    "",
    "int main(void){",
    "    /*---------- 讀入 ----------*/",
    "    if(scanf(\"%d %d\",&M,&N)!=2) return 0;",
    "    for(int i=0;i<M;++i) scanf(\"%d %d\",&R[i].id,&R[i].cap);",
    "    for(int i=0;i<N;++i){",
    "        scanf(\"%d %d %d %d\",&C[i].id,&C[i].stu,&C[i].s,&C[i].e);",
    "        C[i].dur = C[i].e - C[i].s;",
    "    }",
    "    scanf(\"%d\",&bFlag);",
    "",
    "    /*---------- 建 conflicts ----------*/",
    "    for(int i=0;i<N;++i){",
    "        conflicts[i]=0;",
    "        for(int j=0;j<N;++j) if(i!=j){",
    "            if(!(C[i].e<=C[j].s || C[j].e<=C[i].s))",
    "                conflicts[i] |= 1u<<j;",
    "        }",
    "    }",
    "",
    "    /*---------- (1) 求 max hours ----------*/",
    "    bestH=-1; bestC=-1;",
    "    uint64_t assign[MAXM]={0};",
    "    uint64_t full = (N==32)?0xFFFFFFFFu:((1u<<N)-1);",
    "    dfs(0, full, 0, 0, assign);",
    "    int maxHours   = bestH;   /* 保存下來 */",
    "",
    "    /*---------- (2) 求 max courses ----------*/",
    "    bFlag |= 0;               /* 容量限制同題目；此 DFS 只改比較順序就夠 */",
    "    /* 重新初始化 */",
    "    bestH=-1; bestC=-1;",
    "    for(int k=0;k<M;++k) assign[k]=0;",
    "    dfs(0, full, 0, 0, assign);",
    "    int maxCourses = bestC;   /* bestAssign[] 已對應此解 */",
    "",
    "    /*---------- 輸出 ----------*/",
    "    printf(\"max hours %d\\n\",   maxHours);",
    "    printf(\"max courses %d\\n\", maxCourses);",
    "",
    "    if(bFlag==2){",
    "        /* 規定：課程編號小 → 大；同課程已分配好不重複 */",
    "        for(int cid=0; cid< N; ++cid){",
    "            int id = C[cid].id;",
    "            for(int r=0;r<M;++r)",
    "                if(bestAssign[r] & (1u<<cid))",
    "                    printf(\"%d %d\\n\", id, R[r].id);",
    "        }",
    "    }",
    "    return 0;",
    "}"
  ]
}