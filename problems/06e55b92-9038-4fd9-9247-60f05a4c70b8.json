{
  "uuid": "06e55b92-9038-4fd9-9247-60f05a4c70b8",
  "title": "29. 梯形法則定積分計算",
  "createDate": 1747238340000,
  "collections": [
    "eb097620-6eca-4b6b-9bc3-f7adb2b5e94d"
  ],
  "problem": [
    "設計一個程式用梯形法計算特定函數f()在(p,q)間以n等份逼近的積分數值",
    "",
    "函數定義:",
    "<img src='https://imgur.com/iNncU5k.png'>",
    "",
    "使用梯形法計算積分，公式如下：",
    "<img src='https://imgur.com/ugZj2uL.png'>",
    "",
    "其中h = (q - p) / n,  n為切割數",
    "每次增加n切割數(切割數n每次*2)，直到精確到小數後第error位",
    "",
    "注意 : 程式請使用函數指標",
    "",
    "",
    "【輸入說明】",
    "第一行為輸入函數類型，輸入 1 代表選擇 f1，輸入 2代表選擇 f2，輸入 0 結束程式",
    "第二行為輸入四個參數a(函數中的係數)、p(積分區間起始點)、q(積分區間終點)、err(精度要求，表示精確到小數後第error位)",
    "使用者重複輸入,直到輸入0 結束程式。",
    "",
    "範例輸入：",
    "1           \t(selected function)",
    "4 -2 1 9 \t(a, p, q, err)",
    "2          \t(selected function)",
    "1 0 3 9 \t(a, p, q, err)",
    "0            \t(end)",
    "【輸出說明】",
    "輸出根據梯形法計算出的最終結果，答案需輸出到小數點第12位",
    "若輸入不為1、2、0則輸出Invalid",
    "範例輸出：",
    "5.054815608319",
    "29.752380952687"
  ],
  "testcase": {
    "codeType": 1,
    "cases": [
      {
        "input": [
          "1",
          "7 -2 1 8",
          "2",
          "3 0 8 6",
          "0"
        ],
        "output": [
          "7.313135898637",
          "1090.135037251159"
        ]
      },
      {
        "input": [
          "2",
          "-8 9 15 7",
          "1",
          "82 -4 9 6",
          "0"
        ],
        "output": [
          "-43108.329429029007",
          "99.372171786491"
        ]
      },
      {
        "input": [
          "1",
          "1888 -43 40 5",
          "2",
          "-198 200 300 2",
          "0"
        ],
        "output": [
          "2924.417287553500",
          "-48195980452.352424621582"
        ]
      },
      {
        "input": [
          "3",
          "0"
        ],
        "output": [
          "Invalid"
        ]
      }
    ]
  },
  "sampleCode": [
    "#include <stdio.h>",
    "#include <math.h>",
    "",
    "// 函數定義",
    "// f1(x) = sqrt(a-x^2)",
    "double f1(double x, double a) {",
    "    return sqrt(a - x*x);",
    "}",
    "",
    "// f2(x) = (ax^3+7x) / sqrt(a+x)",
    "double f2(double x, double a) {",
    "    // 注意計算順序，避免精度損失",
    "    double numerator = a * pow(x, 3) + 7.0 * x;",
    "    double denominator = sqrt(a + x);",
    "    return numerator / denominator;",
    "}",
    "",
    "// 函數指標類型定義",
    "typedef double (*FuncPtr)(double, double);",
    "",
    "// 梯形法實現",
    "double trapezoid_integration(FuncPtr f, double a, double p, double q, int n) {",
    "    double h = (q - p) / n;",
    "    ",
    "    // 先計算端點值",
    "    double sum = 0.5 * (f(p, a) + f(q, a));",
    "    ",
    "    // 計算中間點的函數值總和",
    "    for (int i = 1; i < n; i++) {",
    "        double x = p + i * h;",
    "        sum += f(x, a);",
    "    }",
    "    ",
    "    return h * sum;",
    "}",
    "",
    "int main() {",
    "    int func_type;",
    "    double a, p, q;",
    "    int err;",
    "    FuncPtr selected_function;",
    "    ",
    "    while (1) {",
    "        // 獲取函數類型",
    "        if (scanf(\"%d\", &func_type) != 1) {",
    "            // 處理輸入錯誤",
    "            printf(\"Invalid\\n\");",
    "            while (getchar() != '\\n'); // 清除輸入緩衝區",
    "            continue;",
    "        }",
    "        ",
    "        if (func_type == 0) {",
    "            break; // 結束程式",
    "        }",
    "        ",
    "        // 驗證函數類型",
    "        if (func_type != 1 && func_type != 2) {",
    "            printf(\"Invalid\\n\");",
    "            continue;",
    "        }",
    "        ",
    "        // 選擇函數",
    "        selected_function = (func_type == 1) ? f1 : f2;",
    "        ",
    "        // 讀取參數",
    "        if (scanf(\"%lf %lf %lf %d\", &a, &p, &q, &err) != 4) {",
    "            printf(\"Invalid\\n\");",
    "            while (getchar() != '\\n'); // 清除輸入緩衝區",
    "            continue;",
    "        }",
    "        ",
    "        // 計算初始結果 (n = 1)",
    "        int n = 1;",
    "        double current_result = trapezoid_integration(selected_function, a, p, q, n);",
    "        double previous_result;",
    "        ",
    "        // 計算容許誤差：精確到小數點後第err位",
    "        double tolerance = pow(10.0, -err);",
    "        ",
    "        // 持續增加切割數直到達到所需精度",
    "        do {",
    "            previous_result = current_result;",
    "            n *= 2; // 每次將切割數加倍",
    "            current_result = trapezoid_integration(selected_function, a, p, q, n);",
    "        } while (fabs(current_result - previous_result) >= tolerance);",
    "        ",
    "        // 輸出結果，精確到小數點後12位",
    "        printf(\"%.12lf\\n\", current_result);",
    "    }",
    "    ",
    "    return 0;",
    "}"
  ]
}